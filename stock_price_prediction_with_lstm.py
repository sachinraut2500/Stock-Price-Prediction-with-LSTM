# -*- coding: utf-8 -*-
"""Stock Price Prediction with LSTM

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a-DaSwyTIVpHrugM4-3iD72lN-5X1nEi
"""

# stock_price_prediction.py
import numpy as np
import pandas as pd
import yfinance as yf
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_absolute_error, mean_squared_error
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')

class StockPredictor:
    def __init__(self, symbol, period='2y'):
        self.symbol = symbol
        self.period = period
        self.scaler = MinMaxScaler(feature_range=(0, 1))
        self.model = None
        self.data = None

    def fetch_data(self):
        """Fetch stock data from Yahoo Finance"""
        try:
            stock = yf.Ticker(self.symbol)
            self.data = stock.history(period=self.period)
            print(f"Data fetched for {self.symbol}: {len(self.data)} records")
            return True
        except Exception as e:
            print(f"Error fetching data: {e}")
            return False

    def preprocess_data(self, lookback=60):
        """Preprocess data for LSTM model"""
        # Use closing price for prediction
        prices = self.data['Close'].values.reshape(-1, 1)

        # Scale the data
        scaled_prices = self.scaler.fit_transform(prices)

        # Create sequences
        X, y = [], []
        for i in range(lookback, len(scaled_prices)):
            X.append(scaled_prices[i-lookback:i, 0])
            y.append(scaled_prices[i, 0])

        X, y = np.array(X), np.array(y)
        X = X.reshape((X.shape[0], X.shape[1], 1))

        # Split data
        split = int(0.8 * len(X))
        self.X_train, self.X_test = X[:split], X[split:]
        self.y_train, self.y_test = y[:split], y[split:]

        print(f"Training data: {self.X_train.shape}")
        print(f"Testing data: {self.X_test.shape}")

    def build_model(self, lstm_units=50):
        """Build LSTM model"""
        self.model = Sequential([
            LSTM(lstm_units, return_sequences=True, input_shape=(self.X_train.shape[1], 1)),
            Dropout(0.2),
            LSTM(lstm_units, return_sequences=True),
            Dropout(0.2),
            LSTM(lstm_units),
            Dropout(0.2),
            Dense(1)
        ])

        self.model.compile(optimizer='adam', loss='mean_squared_error')
        print("Model built successfully")

    def train(self, epochs=50, batch_size=32):
        """Train the model"""
        history = self.model.fit(
            self.X_train, self.y_train,
            epochs=epochs,
            batch_size=batch_size,
            validation_data=(self.X_test, self.y_test),
            verbose=1
        )
        return history

    def predict(self):
        """Make predictions"""
        predictions = self.model.predict(self.X_test)

        # Inverse transform to get actual prices
        predictions = self.scaler.inverse_transform(predictions)
        y_test_actual = self.scaler.inverse_transform(self.y_test.reshape(-1, 1))

        return predictions, y_test_actual

    def evaluate(self, predictions, actual):
        """Evaluate model performance"""
        mae = mean_absolute_error(actual, predictions)
        mse = mean_squared_error(actual, predictions)
        rmse = np.sqrt(mse)

        print(f"Mean Absolute Error: {mae:.2f}")
        print(f"Mean Squared Error: {mse:.2f}")
        print(f"Root Mean Squared Error: {rmse:.2f}")

        return mae, mse, rmse

    def plot_results(self, predictions, actual):
        """Plot predictions vs actual"""
        plt.figure(figsize=(15, 6))
        plt.plot(actual, label='Actual Price', color='blue')
        plt.plot(predictions, label='Predicted Price', color='red')
        plt.title(f'{self.symbol} Stock Price Prediction')
        plt.xlabel('Time')
        plt.ylabel('Price ($)')
        plt.legend()
        plt.show()

    def predict_future(self, days=30):
        """Predict future prices"""
        # Get last sequence from training data
        last_sequence = self.X_test[-1:].copy()
        future_predictions = []

        for _ in range(days):
            pred = self.model.predict(last_sequence, verbose=0)
            future_predictions.append(pred[0, 0])

            # Update sequence
            last_sequence = np.roll(last_sequence, -1, axis=1)
            last_sequence[0, -1, 0] = pred[0, 0]

        # Inverse transform
        future_predictions = np.array(future_predictions).reshape(-1, 1)
        future_predictions = self.scaler.inverse_transform(future_predictions)

        return future_predictions

def main():
    # Initialize predictor
    predictor = StockPredictor('AAPL', period='2y')

    # Fetch and preprocess data
    if predictor.fetch_data():
        predictor.preprocess_data(lookback=60)

        # Build and train model
        predictor.build_model(lstm_units=50)
        history = predictor.train(epochs=50, batch_size=32)

        # Make predictions
        predictions, actual = predictor.predict()

        # Evaluate
        predictor.evaluate(predictions, actual)

        # Plot results
        predictor.plot_results(predictions, actual)

        # Predict future
        future_prices = predictor.predict_future(days=30)
        print(f"Next 30 days predictions: {future_prices.flatten()}")

if __name__ == "__main__":
    main()